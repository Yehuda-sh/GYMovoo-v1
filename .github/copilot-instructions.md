הנחיות עבודה מעודכנות – פרויקט GYMovoo (אוגוסט 2025)
🎯 כללי עבודה בסיסיים
עבודה על קוד קיים: תמיד המשך מהקוד הנוכחי – אל תשכתב מאפס. שמור על עיצוב, צבעים וסגנון קיים. אל תמחוק קבצים או פונקציות ללא אישור מפורש.
שלבי פיתוח: התחל מתשתיות (מצב גלובלי, שירותים) לפני בניית UI. עבור מסך חדש, סיים במלואו (לוגיקה, UI, בדיקות ותיעוד) לפני סימון "בוצע".
מקור אמת – Supabase: כל הנתונים נטענים מהענן (PostgreSQL via Supabase). אין להשתמש עוד בשרתי פיתוח מקומיים או בקובצי JSON כבסיס נתונים. AsyncStorage משמש אך ורק כ-cache זמני, לא כמקור נתונים.
התמקדות בפלטפורמה: כרגע ממקדים פיתוח והפצה באנדרואיד (Expo). iOS משני.
הפחתת כפילויות: חפש ומנע קוד כפול. השתמש ברכיבים/פונקציות משותפים במקום לשכפל. שפר מבנה פרויקט באופן עקבי והסר קוד מת שאינו בשימוש.
בדיקות אוטומטיות: לכל רכיב או שירות חדש או ששופר משמעותית – הוסף בדיקות (יחידה, אינטגרציה, E2E). הבדיקות צריכות לעבור בהצלחה (ממוקמות ב-**tests** או בתוך תיקיות).
פיצ'רים אחרונים: הוסף כפתור "התחברות מהירה" במסך הפתיחה, המתחבר למשתמש אמיתי (מנוי) עם נתונים אמיתיים. אין לאפשר התחברות מהירה לדמו או משתמש עם נתונים חלקיים.
CI/CD: התעסק בהגדרת CI/CD רק במקרה צורך (למשל שחרור גרסה). לא כרגע בפוקוס.
עדכון מידע אישי: כל שדה בפרופיל משתמש ניתן לעריכה, והמערכת חייבת להתעדכן בזמן אמת (באמצעות userStore מסונכרן). ודא שכל שינוי בסנכרון עם Supabase.
רב-לשוניות: אל תשנה טקסטים קיימים בקובצי התרגום. שמור על תמיכה מלאה בעברית ואנגלית בכל מסך (באמצעות i18n). הוסף מפתחות תרגום חדשים לפי הצורך במקום מחרוזות גלויות.
שינויים מינימליים: בשינויים שאינם פונקציונליים, הימנע משינויים גורפים בפורמט הקוד (כגון סגנון או מרווחים). שמור על diff מצומצם כדי להקל על בדיקה.
קומפילציית TypeScript: לאחר כל שינוי בקוד TypeScript, הרץ בדיקת קומפילציה מקומית: npx tsc --noEmit. תקן כל שגיאת טיפוס לפני הגשת הקוד.
🗄️ Supabase ומסד הנתונים (PostgreSQL)
חיבור לענן: האפליקציה כעת מחוברת ל-Supabase (PostgreSQL בענן) ולא לשרת אקספרס מקומי. ודא שקובצי השירות (src/services/api/_) משתמשים בלקוח Supabase (import מ-@supabase/supabase-js) ולא בכתובות http://localhost או דומיהם. אין עוד שימוש ב-fetch/axios לקריאה לשרתי פיתוח.
מבנה נתונים בענן: כל הנתונים (משתמשים, שאלונים, היסטוריית אימונים, סטטיסטיקות וכו') נשמרים בטבלת public.users ב-Supabase. לטבלה יש כ-20 עמודות JSONB שמחזיקות אובייקטים (כגון smartquestionnairedata, workoutplans, activityhistory ועוד).
שמות שדות: במעבר ל-PostgreSQL, כל שם שדה שעבר מ-JSON ל-DB הפך לאותיות קטנות בלבד. לדוגמה, שדה בקוד smartQuestionnaireData יישמר בעמודה בשם smartquestionnairedata. הקפד על תאימות זו בכל CRUD. אם אתה רואה שגיאת "column not found", בדוק אם השתמשת באות גדולה.
משתני סביבה: ודא שקובצי .env (או Expo config) מכילים את הערכים הדרושים לחיבור Supabase:
EXPO*PUBLIC_SUPABASE_URL – כתובת הפרויקט (URL)
EXPO_PUBLIC_SUPABASE_ANON_KEY – מפתח anon לשימוש קליינט
הערה: באפליקציית Expo, prefix EXPO_PUBLIC* נדרש כדי שמשתנים יהיו חשופים לקוד.
Zustand ומצב גלובלי: חנות המשתמש (userStore) נטענת מהענן בעת התחברות ומשתנה בהתאם לפעולות. ודא שכל שינוי לנתוני המשתמש (לדוגמה עדכון פרופיל או השלמת שאלון) מסונכרן ל-Supabase (ע"י קריאה מתאימה ל-supabase.from('users').update(...)) ולא רק ל-AsyncStorage. ה-AsyncStorage משמש כ-cache לקריאה מהירה אך לא מקור סופי.
אין "נתוני דמה" בקוד: אסור ליצור נתונים באופן ידני בקוד (hard-code) שאינם נתוני ממשק. כל המידע – אפשרויות שאלון, תרגילי אימון, תוכניות – צריך להגיע מהענן או מקובצי נתונים מרכזיים. לדוגמה, אל תמציא ערכי שאלון בקוד; השתמש רק בערכים המוגדרים ב-src/data/unifiedQuestionnaire.ts או במאגר התרגילים.
🔄 מעבר משרת מקומי ל-Supabase – מה לוודא?
הסר הפניות לשרת מקומי: חפש בקוד מחרוזות כמו 10.0.2.2:3001 או localhost:3001 וודא שהן אינן קיימות. אם מצאת קריאות axios/fetch לשרת, החלף אותן בשימוש בלקוח Supabase. למשל:
// ❌ לפני:
const res = await fetch(`http://10.0.2.2:3001/users/${id}`);
// ✅ אחרי:
const { data, error } = await supabase.from('users').select('_').eq('id', id).single();
AsyncStorage כ-cache בלבד: ודא שכל שימוש ב-AsyncStorage הוא למטרות אחסון מטמון (cache) או העדפות לוקאליות. אין לשמור שם את כל אובייקט המשתמש כמקור נתונים. לדוגמה, אם רואים בקוד:
const userData = await AsyncStorage.getItem('user');
זה צריך להחליף בשליפה מ-Supabase, ורק לאחר מכן שמירה ל-cache. לדוגמה:
const { data: userData } = await supabase.from('users').select('_').eq('id', userId).single();
await AsyncStorage.setItem('user_cache', JSON.stringify(userData));
עדכון כל השכבות: במעבר, ודא ששכבות גבוהות יותר מעודכנות. למשל, אם userApi.getUsersFromLocalFile() כבר אינו בשימוש – מחק אותו ואת קריאותיו, כדי למנוע בלבול. כל פונקציות ה-API עכשיו צריכות לעבוד מול Supabase (userApi.ts כבר הותאם לכך).
בדיקת חיבור: לפני הרצת האפליקציה, ניתן לוודא שהתקשורת עובדת עם הפקודה: npm run test:supabase. סקריפט זה מוודא התחברות ל-Supabase ופעולות CRUD בסיסיות. הפעל אותו לאחר כל שינוי מהותי בספריית Supabase (מפתח, URL, שמות טבלאות).
📋 אימות קובצי נתונים לפני יצירת משתמשים/דמו
יצירת משתמשי בדיקה או נתוני דמו דורשת הקפדה על ערכים חוקיים ומבנה נכון, כדי למנוע שגיאות. לפני יצירת אובייקטי משתמש חדשים, פעל לפי ההנחיות הבאות:
בדוק ערכים חוקיים: קובץ המרכז את ערכי השאלון המותרים הוא src/data/unifiedQuestionnaire.ts. הוא מכיל את כל האפשרויות לכל שאלה (מין, גיל, מטרות, זמינות, משכי אימון, מיקומי אימון, ציוד, תזונה וכו'). השתמש אך ורק בערכים המוגדרים שם. למשל, ערך גיל חוקי הוא "26_35" (כפי שמופיע בקובץ), לא "25-35".
דוגמה:
✅ "age": "26_35" מופיע בקובץ ולכן חוקי.
❌ "age": "25-35" אינו מוגדר, ולכן לא להשתמש בו.
מקורות נוספים לאמת: ודא גם שערכים מסוימים מוגדרים בקבצי constants או טיפוסים מתאימים:
src/constants/ – בדוק קבועים של תזונה, העדפות, שמות תרגילים וכו' אם יש.
src/types/ – בדוק את ממשקי הנתונים כדי לוודא שאתה ממלא את כל השדות הנדרשים ובסוגי הערכים הנכונים.
בלי "להמציא" שדות: אין להוסיף שדות או אפשרויות שאינן קיימות. למשל, אם אין במערכת שדה strengthLevel, אל תוסיף אותו באופן מקומי לאובייקט המשתמש. השתמש רק בשדות הקיימים במבנה המשתמש הנוכחי (עיין ב-SUPABASE_USERS_SCHEMA.sql ב-docs/ לתמונת מצב של הטבלה).
תוודא מבנה נתונים: לפני יצירת אובייקט משתמש, למד כיצד המסכים מצפים למבנה. לדוגמה:
השוואה בין user.questionnaire (מבנה Legacy) ל-user.smartQuestionnaireData (מבנה חדש) כדי לוודא שאתה ממלא את שניהם בעקביות, אם המערכת דורשת תמיכה לאחור.
מבנה שדות מורכבים: למשל equipment צריך להיות מערך מחרוזות (string[]) ולא מערך של מערכים. אם לא בטוח – בדוק כיצד שדות אלו משומשים ב-ProfileScreen או במסכי אימון.
סמן שאלון כ"מושלם": לאחר מילוי כל שאלות השאלון עבור משתמש חדש, וודא שהמשתמש מסומן כמי שהשלים שאלון. בדרך כלל יש שדה כמו hasQuestionnaire או user.questionnaire.completed – קבע אותו לערך המתאים (true). זאת כדי שהאפליקציה תדע לדלג על מסכי השאלון עבור משתמש זה.
להמחשה, הנה דוגמאות לערכים נכונים ולא נכונים למילוי שדות שאלון:
מין (gender):
✅ "gender": "male" (ערך חוקי לפי השאלון)
❌ "gender": "man" (לא מוגדר בקובץ – לא להשתמש)
גיל (age):
✅ "age": "26_35" (מוגדר)
❌ "age": "25-35" (לא מוגדר)
גובה (height):
✅ "height": "171_180" (מוגדר)
❌ "height": "170-180" (לא קיים)
משקל (weight):
✅ "weight": "71_80"
❌ "weight": "70-80"
מטרות (goals):
✅ "fitness_goal": "build_muscle" (מחרוזת יחידה, או מערך מטרות אם מוגדר כמרובה)
❌ "fitness_goals": ["muscle_gain", "strength"] (לא קיימים ערכי "muscle_gain" או "strength" במערכת)
משך אימון (sessionDuration):
✅ "session_duration": "45_60_min"
❌ "sessionDuration": "45-60" (שם שדה לא נכון וגם ערך לא בפורמט מוגדר)
ציוד (equipment שאלון):
✅ "home_equipment": ["dumbbells", "resistance_bands"] (אם מיקום האימון הוא "home_equipment")
❌ "equipment": ["dumbbells", "barbell"] (שדה לא נכון – צריך להיות מפורט לפי סוג מיקום, וערך "barbell" לא קיים כערך שאלון, אלא כערך תרגילים)
תהליך מומלץ ליצירת נתוני דמו/משתמש חדש נכון:
חקר מקדים: קרא את unifiedQuestionnaire.ts ואת סכמת הטבלה (למשל docs/SUPABASE_USERS_SCHEMA.sql) כדי להבין בדיוק אילו שדות יש ואת שמותיהם.
בדיקת ערכים: רשום מראש את הערכים שתשתמש בהם לכל שאלה, תוך אימות שהם קיימים בקובץ השאלון. לדוגמה, הכנות כמו: gender = "female", availability = "3_days" וכו'.
התאמה למיקום וציוד: אם המשתמש מתאמן בבית ללא ציוד, מלא את שדה workout_location = "home_bodyweight" ושדות הציוד בהתאם: למשל bodyweight_equipment עם הרשימה המתאימה (כגון ["mat_available", "towel_available"]). אל תמלא שדה ציוד שלא שייך למיקום (כלומר, אם מיקום הוא gym, מלא רק gym_equipment, לא home_equipment).
יצירת אובייקט המשתמש: בנה את אובייקט המשתמש בשלמותו. למשל:
const realisticUser = {
name: "שם פרטי ומשפחה",
email: "unique_email@example.com", // חשוב: אימייל ייחודי, אחרת הכנסת הנתונים תיכשל
gender: "female",
age: "26_35",
weight: "61_70",
height: "161_170",
fitness_goal: "lose_weight",
experience_level: "beginner",
availability: "3_days",
session_duration: "30_45_min",
workout_location: "home_equipment",
// ציוד – בהתאם למיקום:
home_equipment: ["dumbbells", "resistance_bands"],
// אם workout_location היה "gym", היינו משתמשים ב-gym_equipment, וכו'.
diet_preferences: "balanced_diet",
// אובייקטי JSONB (שדות בטבלה):
smartquestionnairedata: { /_ נתוני שאלון מלאים לפי המבנה הצפוי _/ },
questionnaire: { /_ גרסת Legacy אם צריך _/ },
preferences: { /_ העדפות משתמש נוספות _/ },
activityhistory: { /_ היסטוריית אימונים מלאה _/ },
workoutplans: { /_ תוכניות אימונים מלאות _/ }
};
⏯️ טיפ: השתמש בפונקציה ליצירת אימייל ייחודי אם צריך לייצר מספר משתמשים, למשל:
const generateUniqueEmail = (baseName) => `${baseName}.${Date.now()}@test.com`;
כך תמנע התנגשויות במפתח הייחודי של עמודת האימייל.
בדיקות לפני החדרה:
הרץ npx tsc --noEmit כדי לוודא שאין שגיאות קומפילציה (למשל, שעברת את כל הטיפוסים הנכונים לאובייקט).
ודא שכל שדה חובה מולא. שדות JSON (כמו preferences, activityhistory) יכולים להיות אובייקט ריק {} אם כרגע אין נתונים – אבל השדה עצמו צריך להתקיים (אחרת Supabase עלול להחזיר שגיאה).
ציוד ודיאטה: בדוק שהשדות המתאימים מולאו ע"פ המיקום. לדוגמה, אל תקרא ל-.join() על מערך gym_equipment אצל משתמש ש-workout_location שלו הוא בית – במצב כזה המערך אולי undefined. נקט זהירות (בדוק if (user.gym_equipment) ...).
ודא שהכנסת את ערך email שלא קיים כבר בטבלה – אחרת תקבל שגיאת "duplicate key value violates unique constraint". ניתן לפתור ע"י מחיקת משתמש בדיקה ישן עם אותו מייל (supabase.from('users').delete()...) או שימוש במייל שונה.
הכנסת הנתונים וולידציה: לאחר הכנסת המשתמש/נתונים דרך סקריפט או באופן ידני:
הרץ שוב את אפליקציית המובייל והתחבר כמשתמש החדש. בדוק שהכל מוצג כהלכה: שהציוד מופיע ברשימה הנכונה (לדוגמה, במסך פרופיל אמור להציג את רשימת הציוד הקיימת אצל המשתמש על בסיס user.workout_location). אם משהו לא מוצג – ייתכן שהמערכת לא מצאה את השדה (בדוק שמות שדות ותאימות).
וודא שהשאלון נחשב מושלם (שהאפליקציה לא מנסה שוב לשלוח את המשתמש החדש למלא שאלון).
בדוק שאין שגיאות במסוף Metro בעת שליפת הנתונים (שגיאות כגון "could not find column \_\_\_" או undefined). במידת הצורך – עדכן את האובייקט ונסה שוב.
זכור: המערכת בנויה כך שניתן להשתמש בנתונים הקיימים בה ולהרחיבם, לא להמציא מערכת חדשה. אם תדבוק בערכים ובמבנים הקיימים, תמנע באגים רבים ותצמצם את זמן הדיבוג. 🎯
🚫 פיצ’רים ורכיבים לא קיימים
אם במהלך העבודה אתה נתקל בהפניה ברורה לרכיב או פיצ’ר שלא ממומש בקוד (למשל, המסמך מדבר על כפתור "עזרה" אך אין בקוד כפתור כזה): עצור ובדוק מול מנהל הפרויקט.
ייתכן שמדובר בפיצ'ר מתוכנן שטרם יושם. במקרה כזה, יש שלוש אפשרויות:
לממש כעת – רק באישור מפורש.
להסיר/להסתיר – אם הפיצ'ר מבלבל משתמשים (למשל כפתור ריק), ניתן להסתירו זמנית. ציין בתיעוד/קוד שההסרה זמנית.
להשאיר הערה – ניתן להשאיר את הקוד/הפניה ולהוסיף TODO או הערה שהפיצ'ר לא פעיל.
אל תבצע מימוש משמעותי או מחיקת פיצ’ר שלם ללא הנחיה ברורה. עדיף להעיר את תשומת הלב של מנהל הפרויקט ולבקש החלטה.
🏗️ מבנה פרויקט וארכיטקטורה
Frameworks והגדרות: האפליקציה בנויה ב-React Native (Expo) עם TypeScript. ניהול ה-state הגלובלי באמצעות Zustand (ראה src/store/).
סידור קבצים:
מסכים (Screens) עיקריים נמצאים תחת src/screens/_ בתתי-תיקיות לפי נושא (למשל Profile/ProfileScreen.tsx, Workout/WorkoutScreen.tsx וכו').
רכיבים (Components) לשימוש חוזר – בתיקיות src/components/common/ (רכיבים כלליים, למשל כפתור חזור), src/components/ui/ (רכיבי UI ספציפיים, למשל טופס אימות) ו-src/components/workout/ (רכיבי כושר מיוחדים, כמו תצוגת תרגיל).
נתונים סטטיים/ראשוניים – בתיקיית src/data/ (למשל unifiedQuestionnaire.ts, equipmentData.ts).
שירותים (Services) – src/services/ – לוגיקה עסקית כמו יצירת משתמש דמו, שליפת תרגילים מ-API חיצוני (WGER), ניהול היסטוריית אימונים וכו'.
חנות (Store) – src/store/ – הגדרת Zustand stores עבור משתמש, אימונים, ממשק.
מסמכים ותיעוד – בתיקיית docs/ וכן קובצי README במידת הצורך. שם נרשמים לקחים, לוגי שדרוג וכו'.
שירותי API חיצוניים: למשל WGER (מאגר תרגילים עולמי) מנוצל לקבלת מידע על תרגילים. האינטגרציה רוכזה בשירות src/services/api/wgerApiService.ts – עודכן בגרסה 2.0 עם מטמון ופורמט נתונים אחיד. שימוש בתרגילים של WGER אמור להעשות דרכו ולא לפזר קריאות API בקומפוננטות.
🔧 דפוסי עבודה קריטיים בפיתוח
הרצה ובנייה: השתמש בסקריפטים המוגדרים ב-package.json:
npm run android / npm run ios – להרצת האפליקציה על אמולטור או מכשיר.
npm start (או npx expo start) – להעלאת Metro Bundler.
npm test – להרצת סט הבדיקות האוטומטיות.
שימו לב: ב-Expo, השתמש ב-npx expo start ולא ב-npm run start אם הגדרת הסקריפט שונה.
בדיקות: קובצי בדיקות (כגון Jest) ממוקמים לרוב לצד הקוד הרלוונטי או תחת תיקיה ייעודית. לדוגמה: src/screens/Profile/**tests**/ProfileScreen.test.ts. לפני מיזוג קוד, ודא שכל הבדיקות עוברות. אם הוספת פונקציונליות, הוסף/עדכן בדיקות בהתאם.
ניקוי imports: לאחר כל שינוי, במיוחד מחיקת קובץ או העברת קוד למודול אחר – יש לעבור על הקבצים ולהסיר import-ים שלא בשימוש. כלי ESlint שלנו אמור לסמן זאת. שמירה על imports נקיים עוזרת למנוע שגיאות בנייה.
קבועים והגדרות: אם אתה רואה במקומות שונים ערכים זהים חוזרים (מחרוזות, מספרים) – שקול להגדירם בקובץ קבועים אחד ולייבא משם. לדוגמה, צבעי המותג נמצאים ב-src/constants/theme.ts, אז אל תשתמש בקוד ישירות ב-"#4287f5", אלא ב-theme.colors.primary. כנ"ל לכל Constant אחר.
צבעים ועיצוב: אין לקבוע צבעים כערכי hex בקוד; תמיד השתמש בקבועי הצבעים מ-Theme (למשל theme.colors.\*). גם מרווחים (spacing) וגופנים מוגדרים ב-Theme. בצורה זו נבטיח אחידות ויכולת שינוי קלה.
RTL ונגישות: האפליקציה תומכת בעברית (RTL) ובאנגלית (LTR). לכן:
הוסף writingDirection: "rtl" לכל טקסט בעברית כדי שכיווניות הטקסט תהיה נכונה (React Native לא מזהה אוטומטית לפי שפה).
בדוק textAlign: לעברית עדיף לרוב ימין (right). לרכיבים גמישים, אפשר להשתמש ב-I18nManager.isRTL כדי לקבוע alignment.
flexDirection: במכולות המכילות טקסט/אייקון, ייתכן שתצטרך row-reverse כשמצב RTL.
נגישות: לכל רכיב אינטראקטיבי (כפתור, קישור, שדה טקסט) ציין accessibilityLabel תיאורי (בעברית), accessibilityRole מתאים (button, link, header וכו'), ו-accessibilityHint אם הפעולה לא מובנת מאליה.
SafeAreaView: חובה להשתמש ב-<SafeAreaView> (מ-react-native-safe-area-context) כעטיפה ראשית בכל מסך חדש, ובעיקר במסכים עם Header עליון או כאלו עם תוכן עד קצה המסך. זה מונע חפיפה של התוכן עם מגרעת/מצלמה (notch) או פסי סטטוס. אם יש דיווח על רכיבים שנחתכים בראש המסך או בתחתית – הוסף SafeAreaView.
שמור על קומיט קטן: הימנע מביצוע רפורמט כולל לכל הקובץ או הכנסת שינויים לא קשורים לתיקון שלך. עדיף קומיטים קטנים וממוקדים בבעיה. הדבר מסייע לקוד סיקור Code Review יעיל ומונע הכנסת באגים צדדיים.
🔍 דיוק הפניות לרכיבים ופונקציות
בעת עבודה עם הקוד והתיעוד, שים לב: אם יש במסמך/משימה הפניה לרכיב, פונקציה או מסך בשמו – ודא שהוא קיים ושמו זהה במדויק.
לפעמים שמות רכיבים דומים ויכולה לקרות טעות. למשל "SmartQuestionnaireScreen" לעומת "UnifiedQuestionnaireScreen". בצע חיפוש מהיר בקוד לאימות.
אם התיעוד מפנה למיקום לא נכון (נניח אומר שקובץ מסוים בתיקיה X אך בפועל הוא בתיקיה Y בשם אחר) – אל תמשיך לפתח על סמך הנחה שגויה. עדכן את מנהל הפרויקט על הפער. ייתכן שצריך גם לתקן את התיעוד.
בדגש על כפתורי ניווט, אייקונים או סקריפטים: בדוק שפונקציות onPress מחוברות, שמות אייקונים תואמים (MaterialCommunityIcons vs Ionicons), ושכל משתנה או קבוע שהמסמך מזכיר – אכן קיים. אם לא, שאל האם להוסיף או שמדובר בשריד היסטורי.
♻️ טיפול במידע מיושן ומיגרציה
לאחר המעבר ל-Supabase, ייתכן שנשארו חלקי קוד ישנים או מסמכים שכבר אינם רלוונטיים (legacy). עלינו לנקותם כדי למנוע בלבול:
זיהוי קוד Legacy:
חפש קוד של שרת Express: import express, שימוש ב-cors, body-parser – אם אלו קיימים, כנראה מדובר בקוד שרת ישן (ייתכן בתיקיית server/). קוד זה כבר לא נחוץ בפרויקט (ה-backend עבר לענן). ניתן להסיר תיקיות שרת מקומיות ו-API Express.
קבצי JSON עם נתוני users/Workouts (למשל storage/db/users.json) – אם עדיין קיימים, הם Legacy ולא בשימוש כעת (נתונים עברו לענן). גבה אותם אם צריך, אבל אל תשען עליהם.
פונקציות כמו userApi.getUsersFromLocalFile() – צריכות להימחק או להתעדכן ל-Supabase.
Scripts כמו npm run server או nodemon ב-package.json – כבר לא רלוונטיים, אפשר להסיר כדי לא לבלבל (בעיקר אם עברנו לענן).
שימוש לא נכון ב-AsyncStorage: ודא שאין מקומות בהם AsyncStorage משמש לשמירת מצב אפליקציה קריטי. לדוגמה, AsyncStorage.setItem('user', JSON.stringify(userData)) ואחר כך שליפה ממנו בכל עלייה – סימן שהיה caching ללא סנכרון. כעת חייבים לוודא שמרעננים מהענן לפחות בתחילת כל Session. ניתן לשמור ב-AsyncStorage רק עותק אחרון שהתקבל מהענן (cache) ולהשתמש בו לטעינה מהירה רק אם צריך offline mode.
משתני סביבה ישנים: אם היו בפרויקט משתני סביבה עבור שרת מקומי (למשל EXPO_PUBLIC_STORAGE_BASE_URL לכתובות אחסון מקומי) – הסר אותם מקובצי env ומהקוד. עכשיו יש רק משתני Supabase כפי שצוין לעיל.
סדר פעולות בניקוי:
🔍 איתור – מצא את כל המקומות בקוד ובמסמכים עם התייחסות למערכת הישנה. (טיפ: חפש מחרוזות ידועות כמו "localhost", "10.0.2.2", "users.json").
✏️ עדכון – הסר/עדכן כל אזכור כזה: החלף בקוד חדש (לדוגמה, קריאת Supabase במקום fetch לשרת). מחק ספריות/קבצים שכבר אינם בשימוש (לא לשכוח לעדכן index.ts אם היו מייצאים).
🧪 בדיקה – הרץ בדיקות (ראו סעיף בדיקות איכות) כדי לוודא שלא נשארו רפרנסים שבורים. לדוגמה, הרץ grep על פרויקט: אין אזכורי "localhost". וודא ש-npx tsc --noEmit עובר (אולי importים לקבצים שמחקת).
📝 תיעוד – עדכן README או מסמכים רלוונטיים: הסר הוראות התקנה לשרת המקומי, עדכן הסברים אודות Supabase, וכו'.
דגלים אדומים (למחיקה מיידית):
❌ כתובת http://10.0.2.2:3001 בכל מקום – מוחק/מעודכן מיד.
❌ שימוש ב-axios.create({ baseURL: ... }) ל-URL מקומי – להסיר.
❌ קובצי JSON מקור נתונים (users.json, workouts.json) – אם לא בשימוש, להסיר כדי למנוע טעויות.
❌ קוד Docker-compose או scripts להרצת DB מקומי – לא רלוונטי, למחוק (אלא אם צריך לשימור היסטורי).
אימות לאחר מיגרציה:
נסה להתחבר באפליקציה (flows של Login/Register) ולוודא שכל נתוני המשתמש מגיעים מ-Supabase כצפוי (בדוק userStore לאחר login – שהשדות מלאים).
וודא שאין שגיאות ברשת (network) בקונסולת Metro – לדוגמה 404 או 500 שמעידות שמנסה עדיין לקרוא משירות ישן.
הפעל npm run test:supabase לוודא שפעולות קריאה/כתיבה עובדות.
אם יש לך גישה לכלי psql או supabase studio, בדוק שהנתונים נכנסו כראוי לטבלאות, במיוחד מבנה JSON: שמות השדות באובייקטי JSON הם Lowercase, ושכל המידע משוקף.
לסיכום: המערכת כעת 100% בענן – ודא שכל שורת קוד מתיישרת עם העיקרון הזה.
📑 ניהול ותיעוד מסמכי הפרויקט
שמירת מסמכים (Docs) נקייה ועדכנית חשובה למניעת בלבול. יש לנו לא מעט קובצי Markdown (מסמכי לקחים, דוחות שדרוג וכו'). ננהג כך:
שימור תובנות חשובות בלבד: נשמור מסמכים שמכילים לקחים משמעותיים, טיפים למניעת טעויות, החלטות ארכיטקטורה עם נימוקים, ודפוסי עבודה מומלצים.
מחיקת "רעש" היסטורי: נסיר תיעוד של ניסויים שכשלו, יומני דיבוג ישנים, רשימות TODO שכבר הושלמו, ודוחות מצב שכבר לא עדכניים. המטרה היא שכל מי שקורא את התיעוד ימצא בו רק מידע מועיל להמשך – לא היסטוריה מכבידה.
ארגון תיקיית docs/: שמור מספר מצומצם של קבצים, מאורגנים לפי נושאים עיקריים. לדוגמה:
CRITICAL_PROJECT_CONTEXT.md – מידע חיוני על החלטות מפתח (אם יש).
COPILOT_INSTRUCTIONS.md – הנחיות מיוחדות לשימוש ב-AI (אם רלוונטי, ראו בהמשך).
README.md – הוראות התקנה, ריצה ותרומה.
אולי ARCHITECTURE.md – תיאור ארכיטקטורה ראשית.
כל היתר – לשלב במסמכים אלו או למחוק.
עריכת המסמכים שנשארים: עברו על כל מסמך שהחלטנו להשאיר וערכו אותו:
הסר חלקים לא חיוניים (למשל, פירוט צעד-אחר-צעד של דיבוג שכבר אין בו צורך).
הדגש את הלקחים ותובנות “מה לעשות/לא לעשות” שנובעים מהניסיון.
אם יש מדדי הצלחה/שיפור – ציין אותם בקצרה (כדי להראות תועלת מהשינויים).
הוסף בכל מסמך "עדכון אחרון: <תאריך>" בראש, כדי שנדע מתי נבדק לאחרונה.
מחיקה בטוחה: מחק ללא חשש קבצים ששמם מעיד שהם זמניים או לא נחוצים: קבצים שמכילים "temp", "debug", "old", "draft".
ביצוע מחיקה: זכרו לעדכן imports אם מחקתם קובץ שיובא במקום אחר (חיפוש מהיר בפרויקט בשם הקובץ וודא שאין שגיאות קומפילציה).
מדדי הצלחה לניקוי: בסיום, אמורים להישאר רק כ-5–10 קובצי תיעוד חיוניים, כל אחד תמציתי. אם נצליח – חיפוש מידע יצטמצם לשניות במקום דקות.
דוגמה: אחרי סבב ניקוי, אפשר לדווח:
🧹 ניקוי תיעוד: נשמרו 7 קבצים חשובים, נמחקו 12 קבצים מיושנים, 3 קבצים מוזגו למסמך אחד.
⏱️ זמן חיפוש מידע חדש צפוי להתקצר משמעותית (חסכון של ~5 דקות לכל מפתח).
המטרה היא שכל מפתח חדש או ותיק שיגיע למסמכים – יקבל תמונת מצב עדכנית וטיפים מעשיים, במקום לקרוא יומנים היסטוריים מיותרים.
🚦 בדיקת השפעת שינויים (Impact Analysis)
בכל שינוי מהותי, חשוב לבחון מעבר לקובץ הבודד שבו שינית:
קבצים תלויים: בדוק אילו קבצים/מודולים נוספים מושפעים ויידרשו עדכון. למשל, אם שינית ממשק (interface) ב-src/types/Workout.ts, חפש היכן הוא בשימוש ועדכן בהתאם.
סנכרון בין מודולים: ודא שמתודולוגיה חדשה או שדה חדש תואם בכל מקום. לדוגמה, הוספת שדה ב-userStore? בדוק שגם מסך הפרופיל, מסך השאלון ושמירת הנתונים ל-Supabase לוקחים אותו בחשבון.
קבצים כפולים/ישנים: ייתכן ושינוי שלך הופך קובץ אחר למיותר או כפול. סמן לעצמך לבחון מחיקה או מיזוג של אותו קוד. (כמובן, בקש אישור לפני מחיקה, כנ"ל).
תרגום: אם הוספת טקסט חדש, זכור להוסיף אותו לקבצי התרגום (he.json/en.json או .po בהתאם) כדי לשמור על דו-לשוניות.
תיעוד: אם השינוי הוא התנהגותי או ארכיטקטוני, רשום לעצמך לעדכן את מסמכי התיעוד בהתאמה (כגון README או Architecture).
Imports שבורים: לאחר מחיקת קובץ או שינוי שם, חפש את שמו בפרויקט (grep_search / Find All) כדי לוודא שאין import שלא עודכן. TypeScript בד"כ יתפוס זאת, אבל במקרה של import דינמי/require ייתכן ויתפספס.
בגישה יזומה זו, נמנע מצב שבו שינוי פותר בעיה במקום אחד אבל יוצר תקלה שקטה במקום אחר. תמיד חשוב לחשוב "מה עוד מושפע מזה?".
📱 בדיקות UI ותאימות מכשירים
לפני מסירת פיצ'ר או תיקון UI, בצע את הבדיקות הבאות:
Safe Area: בדוק במסכי מכשירים עם מגרעת (notch) או מסך מלא (Edge-to-edge). ודא ששום כפתור או טקסט לא נחתך או מוסתר מאחורי סטטוס בר/מגרעת. אם כן – עטוף את התוכן ב-SafeAreaView.
RTL מול LTR: החלף את שפת הממשק בין עברית לאנגלית (אפשר ב-Expo Dev Menu). ודא שהמסך נראה טוב בשני המצבים: שורות טקסט מתיישרות נכון, סדר רכיבים (ימין-שמאל) מתהפך כנדרש, אייקון חץ החזרה מתהפך (ב-RTL אנו משתמשים ב-cheveron הפונה ימינה כדי לסמל "back"). אם משהו נראה הפוך או לא ממוקם – תקן עם style מותנה או התאמה.
ניווט וכפתורים: בדוק את זרימת הניווט. למשל, כפתור "שמירה" אכן חוזר למסך הקודם או היכן שצריך. כפתור "חזור" (Back) מחזיר נכון, או מנווט למסך חלופי אם אין היסטוריה. אם כפתור לא מגיב:
ודא שיש לו onPress שמחובר לפונקציה הנכונה.
בדוק שאין רכיב שקוף שמכסה אותו (אפשר זמנית לתת לכפתור צבע רקע חצי-שקוף כדי לראות אם משהו עליו).
אם מדובר בכפתור Tab ב-Tabs Navigator, יש באג מוכר: הפתרון הוא להגדיר אותו כ-TouchableOpacity (ראה סעיף "פתרון תקלות" למטה).
שכבות ומודלים: אם אתה פותח מודל (Modal) או Tooltip, ודא שהוא מופיע מעל כל התוכן ולא מוסתר בגלל overflow: hidden או zIndex לא מספיק. במיוחד במצבי Android. השתמש ב-Portal/Provider אם צריך (למשל react-native-paper Portal).
גלילה: אם במסך עם גלילה (ScrollView/FlatList) חלק מהתוכן נחתך או לא נגיש, בדוק:
שהגובה/מיקום ScrollView מוגדר נכון (ייתכן צריך flex:1 על הקונטיינר).
עבור ScrollView בתוך ScrollView (או FlatList בתוך ScrollView), ייתכן צורך ב-nestedScrollEnabled={true} (באנדרואיד).
הוסף מרווח תחתון גדול (paddingBottom) לתוכן הנגלל, כדי לאפשר לגלול את הפריט האחרון מעל כפתורי הניווט/טאב. לפעמים 200–300 פיקסל רווח נדרשים.
אייקונים: אמת שהאייקונים הנכונים משומשים. עבור RTL, אנחנו משתמשים ב-Ionicons chevron-forward במקום chevron-back כדי שיראה לכיוון שמאל (מה שמשתמע כ-"Back" בעברית). אם יש אייקון כיוון אחר – אולי צריך להתנות לפי I18nManager.isRTL.
נגישות (Accessibility): הפעל VoiceOver/‏TalkBack על האפליקציה:
בדוק שכל כפתור מוכרז עם טקסט הגיוני (AccessibilityLabel). למשל, אם יש אייקון בלבד – ודא שהגדרת label, אחרת הקורא מסך יאמר "לחצן לא מתויג".
בדוק סדר פוקוס: אפשר לנווט באפליקציה עם מקלדת (tab order) או בכיוון ממשק ולוודא שהסדר הגיוני.
ביצוע בדיקות אלו בכל רכיב חדש או מסך ששונה מבטיח איכות חוויית משתמש, במיוחד עבור דוברי עברית ומשתמשים עם צרכים מיוחדים.
🛡️ בטיחות בשינויים
שמירה על הליבה: הימנע משינויים בקוד הלוגיקה העיקרית שאינם קשורים למשימה שלך. אם צריך, צמצם את ההשפעה. לדוגמה, אם אתה מתקן באג במסך אימון, עדיף לא "לשפץ" בו-זמנית גם את כל מנגנון הניווט באפליקציה – חלק את העבודה לשלבים.
קבלת אישור: עבור שינויים מבניים משמעותיים (כגון שינוי שמות קבצים רבים, מחיקת פיצ'ר שלם, שכתוב אלגוריתם מרכזי) – קבל אישור מהמנהל לפני. ייתכן שיש סיבות היסטוריות למצב הנוכחי, ועדיף לוודא.
פונקציונליות עיקרית: אל תמחק לעולם פונקציה עיקרית בלי לוודא שהיא באמת לא נחוצה. לדוגמה, גם אם כרגע לא רואים שימוש ב-"quick help button", ייתכן שמתכוונים להחזירו. ניתן להסתיר UI במקום מחיקה סופית, ולציין זאת.
שמירת תקינות TypeScript: בכל עת, ודא שהפרויקט חף משגיאות TypeScript. אנחנו עובדים עם "strict": true. אין להשאיר שגיאות TS (או להשתמש ב-any עוקף) כ"נטע זר". עדיף לפתור את סוגיית הטיפוס נכונה.
תקינות build: לאחר השלמת פיצ'ר, הרץ Build (אנדרואיד: expo build:android או EAS אם מוגדר) כדי לוודא שהאפליקציה נבנית בהצלחה למכשיר. היו מקרים שדברים עובדים ב-dev אך נופלים ב-production (למשל import של מודול Node.js שלא נתמך). עדיף לתפוס זאת מוקדם.
💡 הנחיות לעוזר AI (Copilot) ולשימוש בו בפרויקט
(הסעיף הבא רלוונטי כאשר אנו עובדים עם GitHub Copilot או ChatGPT לסיוע בפיתוח. מטרתו לוודא שהכלים הללו ישתלבו חלק ונכון בתהליך.)
🤖 הנחיות מיוחדות לשימוש ב-GitHub Copilot / ChatGPT
💬 סגנון ואופן אינטראקציה
שפת תקשורת: כל ההנחיות והתגובות באפליקציה ובמסמכים יהיו בעברית עבור משתמשי הקצה. לכן, גם בתקשורת עם כלי AI לגבי תוכן אפליקטיבי, ניסוח התשובות אמור להיות בעברית (למעט מילות מפתח בקוד, שמות קבצים ופקודות טכניות – אותן נשאיר באנגלית).
תמציתיות: יש לשאוף לתשובות קצרות וענייניות. הימנע משימוש בלשון ציורית או סופרלטיבים ("מדהים", "מעולה מאוד"). עדיף לגשת ישר ולעניין.
נימוס ואובייקטיביות: תשובות אמורות להיות מועילות ולא אישיות. לדוגמה, "נמצא שגיאה ב-X, יש לתקן כך וכך" – במקום "אני חושב ש...". אין צורך בפניה אישית ("יקירי" וכד').
מבנה תשובה: כאשר מתבקש הסבר או דו"ח טכני, העדף הצגת המידע ברשימות נקודתיות, צעדים או טבלאות קצרות במקום פסקאות ארוכות. פורמט היררכי (כותרות, תת-כותרות) עוזר לקריאות.
הצעת פעולות: אם מתבקשת עזרה פרוצדורלית (למשל "איך אני בודק קובץ X?"), ספק סדרת פעולות ברורה וממוספרת, כולל פקודות טרמינל אם צריך, והסבר קצר לכל צעד.
מעקב אחר הנחיות: במידה והמפתח (המשתמש) נותן כללים או פורמט רצוי – עקוב אחריהם במדויק. לדוגמה, אם נאמר "הצג את הפלט כטבלה", הקפד על Markdown של טבלה.
🔐 כללי הפעלת טרמינל ו-Expo עם Copilot
כאשר משתמשים ב-Copilot לסיוע בהרצת פקודות:
הרצת פקודות: לעולם אל תשלח פקודת Terminal שלא התבקשת במפורש, במיוחד פקודות מערכת (כגון rm -rf).
פקודות אסורות: אין להשתמש בפקודות timeout או sleep כדי להשהות את ה-Terminal – אלה חסרות טעם בסשן אוטומטי ועלולות לגרום לתקלות.
Expo Refresh: אם האפליקציה כבר רצה ב-Expo (Metro bundler פעיל), אל תנסה להריץ npm start או expo start שוב בטרמינל חדש – זה מיותר ומתנגש. במקום זאת, אם מבקשים לרענן, יש להנחות את המשתמש ללחוץ r בטרמינל הקיים של Metro (או להשתמש באפליקציית Expo Go כדי לרענן).
פתיחת טרמינל נוסף: רק במקרה של צורך בהרצת פקודה במקביל (למשל jest --watch לצד Expo), פתח טרמינל חדש. אך לעולם לא לצורך ריענון Expo.
סביבת Windows: אם המפתח על PowerShell/Windows, הקפד להתאים פקודות:
השתמש בכלי העזר הפנימיים (כגון grep_search אצלנו במקום פקודת grep ישירות).
פקודות כמו cp, mv – תחליף בפקודות PowerShell דוגמת Copy-Item או פשוט ודא שהשימוש נכון.
אל תשתמש בפקודות לינוקס שאינן מובנות ב-PowerShell (כמו head, tail) – אלא אם הגדרנו כלי עזר.
📋 דגשים לתיעוד ואי-שימוש בנתונים דינמיים
בעת כתיבת תיעוד (README, הערות בקוד, תשובות לשאלות):
בלי נתונים משתנים: אל תכתוב בתיעוד מספרים או נתונים שיכולים להשתנות עם הזמן או בין משתמשים, כדי לא להטעות. למשל, במקום "למשתמש יש 69 אימונים מושלמים ו-4,817 דקות אימון", כתוב "למשתמש יש היסטוריית אימונים מרשימה" או "נתוני האימונים מחושבים ומוצגים באפליקציה".
הימנע מדירוגים ספציפיים: למשל אם יש מערכת דירוג, אל תציין "ממוצע 4.5/5 כוכבים" בתיעוד – זה עשוי להשתנות.
ניסוח כללי: למשל, במקום "האפליקציה מציגה טבלת שיאים שבועית שבה המשתמש במקום השני", ציין "האפליקציה מציגה טבלת שיאים שבועית המשווה בין משתמשים".
המטרה היא שהתיעוד יהיה מדויק לאורך זמן, ולא ישקף נתוני דמו רגעיים. נתונים מספריים שיכולים להתעדכן – שמורים לתצוגה בתוך האפליקציה, לא למסמכי הקוד.
🌟 הקשר ומידע חשוב על הפרויקט (Context for Copilot)
שם הפרויקט: GYMovoo – אפליקציית כושר חכמה בעברית. (מושג: Gym + Movoo<Movement, אולי).
מטרה ופיצ’רים עיקריים: מתן תוכניות אימון מותאמות אישית באמצעות שאלון חכם בן 7 שאלות, התאמה למגדר, רמת ניסיון, ציוד זמין ועוד. כולל מאגר תרגילים רחב (בעברית, עם שימוש גם ב-API חיצוני לעשרות תרגילים באנגלית), ומערכת AI שבונה אימונים אישית.
מצב נוכחי: האפליקציה כוללת כ-27 מסכים עיקריים פעילים (מסכי הרשמה, פרופיל, שאלון, אימון, היסטוריה, דאשבורד וכו'). יש כ-12 רכיבים חוזרים (כפתורים, מודלים אישור, תצוגות תרגילים וכו'). שירותים מרכזיים: ~15 (למשתמש, אימונים, היסטוריה, תרגילים, תזונה אולי).
אינטגרציות: אינטגרציה משמעותית היא עם WGER API (מאגר תרגילי כושר גלובלי באנגלית) – משם מושכים מידע על תרגילים שלא קיימים במאגר המקומי, כולל תמונות והסברים. שירות wgerApiService.ts שודרג לגרסה 2.0.0:
איחוד ממשקים: כעת השירות מחזיר מבנה אחיד WgerExerciseInfo לכל התרגילים (במקום כמה פורמטים ישנים).
מטמון חכם: צימצמנו ~90% מקריאות ה-API על ידי cache מקומי (זמין ב-mappingsCache בתוך השירות).
הסרת כפילויות: פורמט הנתונים אוחד כך שאין יותר ממשקי Exercise כפולים (לשעבר היה WgerExerciseFormatted בנפרד – בוטל).
שיפור ביצועים: הסרת המרות מיותרות, טעינת נתונים מוקדמת.
תכונות חדשות מיולי-אוגוסט 2025:
שירות דמו מציאותי: שירות יצירת משתמש דמו עם נתונים "אמיתיים" (ב-demoUserService.ts) שודרג. הוא מייצר היסטוריית אימונים מפורטת, תוכניות מלאות וכו'. הקוד הוטמע במערכת ומסומן היטב (isDemo: true אצל משתמש דמו).
היסטוריית אימונים: מסך HistoryScreen עבר שדרוג מלא – הוא כעת תומך 100% בנתונים אמיתיים מהענן ובנתוני הדמו. הוא מציג גרפים, סיכומים שבועיים וכו'.
התאמה למגדר: הודעות והמלצות האימון מותאמות כעת למין המשתמש. התשתית: השאלה הראשונה בשאלון (מין) משפיעה על תוכן הטקסטים בהמשך (למשל שימוש בלשון זכר/נקבה).
ניהול גלובלי: שיפרנו את ה-userStore וה-workoutStore לסנכרון טוב יותר: עדכון נתונים בזמן אמת כאשר משתמש משנה משהו (פרופיל, יעד חדש וכו' משפיעים מיידית על התוכנית).
ארכיטקטורה – ניווט:
יש Navigator ראשי (Stack) שמוגדר ב-AppNavigator.tsx.
בתוך הסטאק, מסך ראשי שמכיל Bottom Tabs (מוגדר ב-BottomNavigation.tsx).
כל Tab מוביל לסטאק משני (למשל Tab "אימונים" מוביל למסכי WorkoutStack, Tab "פרופיל" לפרופיל וכו').
אנו משתמשים ב-react-navigation v6.
שימו לב לבעיית כפתורי ה-Tabs: כדי שייטענו כפתור חזור נורמלי, הגדרנו headerLeft מותאם עם <BackButton /> ברבים מהמסכים.
AI System: חלק מבחירת התרגילים ויצירת התוכניות מנוהל ב-src/services/workoutDataService.ts (אלגוריתם לבניית אימון מותאם). כרגע אלגוריתם די בסיסי אבל בנוי להתרחב (משתמש בנתוני השאלון והתעדכנות לפי התקדמות).
שאלון חכם מאוחד: תחת src/components/common/UnifiedQuestionnaire.tsx ו-UnifiedQuestionnaireScreen.tsx – מימוש חדש של שאלון היכרות (10 סטים של שאלות, חלקן מותנות זו בזו). תומך גלילה מלאה, RTL ו-LTR, תמונות ואייקונים.
מאגר ציוד: בקובץ src/data/equipmentData.ts רשימה של מעל 100 פריטי ציוד אפשריים (ביתיים, חדר כושר, קרדיו). משמש לבדיקת תקינות תשובות השאלון וגם להצגת ציוד מומלץ בתרגילים.
ניהול State גלובלי:
userStore – מכיל פרטי משתמש, תשובות שאלון (legacy וחדשות), העדפות, מצב מנוי וכד’.
workoutStore – מכיל את האימון הנוכחי, תוכניות זמינות, תרגיל נוכחי וכו'.
historyStore – מכיל את היסטוריית האימונים (לטעינה מהירה במסך היסטוריה).
שלושת אלו מסתנכרנים עם Supabase: userStore נטען/מתעדכן מהענן, workoutStore מתרענן כשמשתמש מסיים אימון (שולח לענן), וכו'.
📝 דגשים טכניים וקונבנציות בפרויקט
BackButton אחיד: יש קומפוננטה אחידה לחזור לאחור: src/components/common/BackButton.tsx. תמיד השתמש בה במקום ליצור TouchableOpacity משלך.
קומפוננטה זו כבר מטפלת ב-RTL: היא מציגה אייקון חץ פונה לכיוון הנכון (Ionicons chevron-forward עבור RTL, שנראה כמו חץ ימינה – שזה בעצם "חזור" בעברית).
פרופס חשובים: absolute (Boolean, אם נדרשת הצבה אבסולוטית במסכים מסוימים), variant (סגנון – "default" / "minimal" / "large"), onPress מותאם (אם רוצים פעולה שונה מברירת המחדל של navigation.goBack()).
כברירת מחדל, לחיצה עליו תקרא navigation.goBack(). אם אין היסטוריית ניווט, היא לא תעשה כלום – במקרים כאלה שקול להחליף לניווט מסך ראשי (ניתן לבדוק navigation.canGoBack() ולנתב אחרת).
נגישות: מוגדר כבר accessibilityLabel="חזור" ו-accessibilityRole="button". אין צורך לשנות.
אין להשתמש ישירות ב-Ionicons chevron-back – זה יראה לא נכון בעברית.
ConfirmationModal במקום Alert: כיוון ש-Alert.alert של React Native לא מותאם RTL (הכפתורים תמיד מסודרים שמאל לימין) ואין שליטה בסגנון שלו, יצרנו קומפוננטה <ConfirmationModal> ב-src/components/common/ConfirmationModal.tsx.
השתמש בה כדי להציג הודעות אישור/התראה למשתמש. היא תומכת בעברית (טקסטים מיושרים לימין, כפתור ביטול ואישור כפי שצריך).
שימוש טיפוסי:
const [showModal, setShowModal] = useState(false);
const [modalConfig, setModalConfig] = useState({ title: "", message: "", onConfirm: () => {} });

// לפתיחת מודל:
setModalConfig({
title: "אישור פעולה",
message: "האם אתה בטוח שברצונך למחוק את התרגיל?",
onConfirm: () => handleDeleteExercise(),
});
setShowModal(true);
וב-JSX:
<ConfirmationModal
visible={showModal}
title={modalConfig.title}
message={modalConfig.message}
onClose={() => setShowModal(false)}
onConfirm={() => { setShowModal(false); modalConfig.onConfirm(); }}
onCancel={() => setShowModal(false)}
confirmText="אישור"
cancelText="ביטול"
destructive={true} // במידה וזו פעולה מסוכנת (מחיקה)
/>
אל תשתמש ב-Alert.alert ישירות – זה פחות נגיש וגם לא תומך RTL כראוי.
רכיבי UI ונגישות: להלן דוגמאות מוסכמות לשילוב נגישות ברכיבים אינטראקטיביים:
כפתור (TouchableOpacity) סטנדרטי:
<TouchableOpacity
style={styles.button}
onPress={handleAction}
accessibilityLabel="הפעל פעולה מסוימת"
accessibilityRole="button"
accessibilityHint="לחץ כדי לבצע את הפעולה"

> <Text style={styles.buttonText}>לחץ כאן</Text>
> </TouchableOpacity>
> כפתור Toggle/Switch בהתאמה אישית:
> <TouchableOpacity
> onPress={() => setEnabled(!enabled)}
> accessibilityRole="switch"
> accessibilityLabel={enabled ? "לחץ כדי להשבית התראה" : "לחץ כדי להפעיל התראה"}
> accessibilityState={{ checked: enabled }}
>
> <View style={[styles.toggle, enabled && styles.toggleOn]} />
> </TouchableOpacity>
> כאן השתמשנו ב-accessibilityRole="switch" ונתנו state של checked.
> IconButton (כפתור אייקון ללא טקסט):
> <TouchableOpacity
> onPress={openSettings}
> accessibilityLabel="הגדרות"
> accessibilityHint="פתח את מסך ההגדרות"
> accessibilityRole="button"
>
>   <Ionicons name="settings-outline" size={24} />
> </TouchableOpacity>
> שדה טקסט (Input): אם משתמשים ברכיב <InputField> ייעודי, ודא שלתכונה label יש ערך, והיא בדרך כלל כבר מגדירה נגישות. למשל, <InputField label="שם מלא" ... /> יצור אוטומטית label נגיש עם הטקסט "שם מלא".
> Avatar (תמונת פרופיל): בקומפוננטה כמו <DefaultAvatar name={user.name} /> יש אצלנו טיפול – היא תגדיר accessibilityLabel כמו "תמונת פרופיל של <השם>". כדאי לוודא שזה קורה (לפי הקוד). אם לא – הוסף זאת.
> תמיכה מלאה ב-RTL: כללנו כבר את רוב התמיכה, אבל שים לב לדברים הבאים:
> אייקונים של כיוון (חיצים, חזור) – כפי שציינו, משתמשים בגרסת ה-RTL (chevron-forward).
> מרווחים ופדינג: אם למשל היה marginLeft עבור מרכיב בשפה אנגלית, ייתכן שצריך להחליף או להוסיף marginRight עבור עברית. במקרים כאלה אולי עדיף להשתמש ב-StyleSheet.absoluteFill וכדומה או להפוך כיוון flex.
> בדיקה בפועל: השתמש בפונקציה I18nManager.forceRTL(true) במצב פיתוח (או פשוט הגדר שפת ממשק=עברית) כדי לראות שכל הפינות טופלו. לפעמים דברים קטנים מתפספסים (כגון אייקון קטן בתוך טקסט שלא התהפך).
> טיפוסים ב-TypeScript:
> ללא Any: הפרויקט שואף ל-0 שימוש ב-any. אם אתה כותב קוד חדש, הגדר את הטיפוסים או השתמש בממשקים קיימים. אם אתה בצומת שמחזיר סוג משתנה, שקול להגדיר Union types או להפצל לפונקציות נפרדות טיפוס.
> Casting זהיר: עדיף להימנע מ-as unknown as Type אלא אם אין ברירה. לרוב, אפשר לפתור עם generics נכונים או לשפר את מבני הנתונים.
> ממשקים מרכזיים: נסה לאחד ממשקים כאשר אפשר. למשל, אם יש שני Interface כמעט זהים לשני שירותים, חשבו אם אפשר לרשת מאחד או ליצור ממשק בסיס. אבל אל תעשה זאת על דעת עצמך אם זה שינוי גדול – תכנן עם הצוות.
> פריקת קבצים גדולים: אם קובץ עובר ~500 שורות, בדוק אם אפשר לחלקו באופן הגיוני. למשל, מסך ענק שמכיל גם 5 קומפוננטות פנימיות – שקול להוציא את הקומפוננטות לקבצים משלהן בתיקיית המסך. הדבר משפר קריאות ותחזוקה.
> נתיבים יחסיים: עקב תמיכה ב-Metro bundler ו-EAS, אנו נמנעים מ-import בנתיבים אבסולוטיים או Alias שלא מוגדר נכון. השתמש בנתיב יחסי (../../) כדי לייבא בין מודולים. יש לנו Alias @env למשתני סביבה, אבל חוץ מזה – relative.
> הערות דו-לשוניות: בקבצי הקוד אנו משתדלים לכתוב הערות גם באנגלית וגם בעברית, במיוחד אם זה קוד שיסתכלו עליו מפתחים שאינם דוברי עברית. למשל:
> // Validate input length (אימות אורך קלט)
> זה לא חובה בכל שורה, אבל בהסברים ארוכים – אפשר לשלב, או לפחות באנגלית כדי לקהל רחב.
> JSDoc לתיעוד קבצים: בראש כל קובץ משמעותי, הוסף תגיות JSDoc עם תקציר ורשימת דברים מיוחדים אם יש:
> /**

- @file ProfileScreen.tsx – מסך פרופיל משתמש
- @brief מציג את פרטי המשתמש ונותן אפשרות עריכה והצגת סטטיסטיקות.
- @dependencies userStore, workoutStore (לשליפת נתונים גלובליים), BackButton
- @known_issues דורש שיפור בטעינת תמונת פרופיל (TODO)
- @updates 2025-08: נוספה הצגת יעד כושר ואפשרות שינוי מגדר
  \*/
  השתמש בתגיות כמו @notes, @todo, @update לתיעוד שינויים משמעותיים. זה עוזר בהבנת ההיסטוריה של הקובץ.
  🚀 הצלחות אחרונות ושיפורים בולטים
  (סעיף זה מסכם כמה מהשדרוגים שביצענו, כדי שתבין את הרציונל ואם תוסף עוד שינויים בעתיד שתדע על מה להסתמך)
  איכות קוד ו-TypeScript: אפס שגיאות TypeScript. בעדכונים האחרונים הסרנו את כל ה-any הבעייתיים. הטיפוסים כעת מחמירים, מה שמונע המון באגים מקדימה.
  נגישות: עברנו על כל הרכיבים והוספנו תוויות נגישות. כעת האפליקציה כמעט 100% נגישה: קורא מסך מקריא כראוי, כפתורים מסומנים, ניתן לתפעול ללא ראייה.
  RTL מושלם: תיקנו כל בעיה שמצאנו ב-RTL. למשל, כפתור חזור (BackButton) – לפני כן השתמשנו ב-chevron-back ונראה מוזר, כעת chevron-forward נראה ומרגיש נכון. הטקסטים מיושרים, סדר האלמנטים מותאם.
  ביצועים טובים: מיטבנו טעינות – אפליקציה עולה מהר מבעבר (Launch < 2 שניות במכשירי בדיקה), מעבר בין מסכים חלק (שמרנו state ו-cache היכן שאפשר), וניטרלנו אנימציות כבדות.
  מניעת באגים חוזרים: הנה דוגמה ללקח שמומש: הייתה בעיה שכפתורי הניווט התחתון לא הגיבו ללחיצה. זיהינו שהסיבה היא שימוש ב-View במקום TouchableOpacity ב-tabBarButton. תיקנו זאת בכל מקום – עכשיו זו כבר לא בעיה.
  שיפור תהליך פיתוח: הכנסנו Pre-commit Hooks (Husky) שבודקים קומפילציית TS ו-ESLint לפני כל commit. זה חוסך זמן – אין יותר קומיטים שעוברים CI עם שגיאות סינטקס פשוטות.
  תהליך "תבדוק לי": פיתחנו פרוטוקול בדיקה מובנה (חצי אוטומטי) בעת בקשה. הוא כולל בדיקת גודל קובץ, מורכבות, בדיקת חיבור Supabase וניתוח בעיות נפוצות – מה שמייעל Code Review פנימי.
  מדידות הצלחה: למשל, יצירת משתמשי דמו: בעבר לווה בשגיאות ("column not found", "duplicate key"). אחרי הגדרת התהליך הנכון, הצלחנו ליצור 10 משתמשי דמו ריאליסטיים במכה אחת ללא שגיאה. זמן העבודה התקצר בכ-75%.
  "כלל הזהב" שלנו: תן לקוד הקיים ללמד אותך, במקום לנסות ללמד אותו ע"י ניסוי וטעייה. כלומר – לפני שמנסים לנחש פתרון, חפשו במערכת, במסמכים, בבסיס הנתונים – כנראה שכבר יש דרך נכונה לעשות זאת. כשניצמד לכלל הזה, נחסוך המון זמן ותסכול. 💡
  עם הנחיות אלו, אנו מצפים שתהליך הפיתוח יהיה חלק, מהיר ובטוח יותר. אם משהו עדיין לא ברור – תמיד עדיף לשאול ולוודא, מאשר להתקדם בכיוון שגוי. בהצלחה! 🚀
